I coded these solutions using Java to refamiliarize myself with the language before college.


WEEK 1 (75 questions version)

1. Two Sum - Create a HashMap<Integer, Integer> to store each (number, index) in the array. Iterate through the entirety of nums, and set target2 to the value of
target - nums[i]. If the map contains target2 as a key, then the sum can be made, so return the indices. Otherwise, add nums[i], i to the HashMap and continue.

2. Valid Parentheses - Create a Stack of Characters charStack. Iterate through each character of the entire string, and if the char is an open parentheses form, 
just add it to the stack. Otherwise, if it is a closed parentheses form, check whether the stack is empty or if stack.pop() doesn't equal the open form of that
exact parentheses. If either of these conditions are true, return false. At the end of the loop, if the stack is empty, return true; otherwise, return false. 

3. Merge Two Sorted Lists - Create a new ListNode ret with a dummy head of 0 (this is really convenient for the problem; at the end, we just return ret.next). Then, 
create an auxillary node retAux that points to the new ListNode that we will use to expand our list. While both list1 and list2 are not null, if list1.val > list2.val, 
then we set retAux.next = list2 and list2 = list2.next. Otherwise, replace do the same but with list1. At the end of each iteration, do retAux = retAux.next. 
At the end of the loop, either list1 or list2 will be null, so we just add the rest of whichever one isn't null to the rest of our new list. Then, we return ret.next,
the head of our linked list (bc of the dummy head).

4. Best Time To Buy And Sell Stock - Simple problem after some thought. Keep two variables profit (originally 0) and currMin (originally Integer.MAX_VALUE). Iterate
through the array, and keep track of the minimum value of currMin (see if we can change it every iteration). Also, if our current profit is less than prices[i] - 
currMin, then we set profit to that value. Remember, we have to buy stock on a day before we sell stock, so we can only look at selling after our currMin index. Then,
at the end of the loop, just return profit. 

5. Valid Palindrome - Two pointers method. First, create an empty string "", and iterate through the string and use the Character.isDigit(c) and Character.isLetter(c)
to remove all unecessary characters from the input string in our empty string. Then, do emptystring.toLowerCase(), and use left pointers and right pointers, starting 
at each end, and while lp <= rp, if character at lp != character at rp, then return false. Each iteration, do lp++ and rp--. If the end of the loop, is reached,
return true.

6. Invert Binary Tree - Recursive solution, as is with many tree questions. You can probably simplify my code more. Firsly, if initial root == null, return true,
otherwise use invertTreeAuxillary function, which will return the inverted tree. In the function: if both node.left and node.right are null, just return the node (my
code calls it root -- because it essentially is the root of a smaller subtree). If .right is null but .left is not, then we do node.left = invertTreeAux(root.right),
and vice versa if .left is null but .right is not, then return node. Otherwise, both .left and .right are not null, so we must invert both of them, and we use a holder
variable to store one of the subtrees to be able to do this. 

7. Valid Anagram - Converted both strings to arrays of chars using .toCharArray(). Then, sort the arrays using built in Arrays.sort, create new Strings by doing
String s2 = new String(char array) for both char arrays. If they are equal (remember to use .equals() not == for Strings), return true, otherwise return false.

8. Binary Search - Plain binary search. Something to remember is that when changing the bounds you should do lp = mid + 1 or rp = mid - 1, not just lp = mid etc.

9. Flood fill - Recursive solution. Find the original color of the source square, and if it's already the color, just return the image. Find the length and width
of the image, then use the floodFillAux with image, sr, sc, original color, color to change to, l, and w. First, change image[sr][sc] to the color, then, dependent
on bounds, do the same for all 4 directions if it's in the bounds of the image and the pixel at those coordinates are the original color. If none of the conditions 
are met, just return. 

10. Maximum Subarray - Classic problem. Keep 2 variables, sum and best. First, assign sum and best to nums[0]. Then, read in the rest of the array, and set
sum to the max of nums[i] and sum+nums[i], and best to the max of best and sum. Return best at the end. 

11. Lowest Common Ancestor of a Binary Search Tree - Use a while loop. While root.left and root.right != null, if p.val is less than or equal to root.val AND
q.val is greater than or equal to root.val or vice versa, return the root (they are on different sides of that root, so that root has to be the LCA. Otherwise,
if both values are less than the root, set root = root.left. Otherwise, set root = root.right. 

12. Balanced Binary Tree - Probably the trickiest problem in week 1 for a specific reason. This answer uses recursion. Firsly, if the initial root is null, then 
just return true. Otherwise, use recursion and an auxillary function isBalancedAux. This function just calculates the height of a tree. We calculate the height 
of the left and right subtree from the root, and if the absolute value of their difference is <= 1, then the ROOT is balanced. However, we also have to make sure 
that EVERY node in the tree is also balanced, so we also have to check isBalanced(root.left) and isBalanced(root.right) -- this will check every node in the 
original tree.

13. Linked List Cycle - My original and much slower solution used an ArrayList to keep track of what nodes we had visited so far, and if we ended up at one 
that was visited again, there would be a cycle and we would return true, otherwise return false. A much better solution is 2 pointers with a slow pointer and 
fast pointer. Firstly, if head is null, return false. Then, we create 2 ListNodes, slow and fast, and set slow = head and fast = head.next. The slow pointer
will move one step at a time while the fast pointer will move two steps at a time. If there is a cycle, the fast pointer will eventually catch up to the slow one.
If fast or fast.next ever equals null, then there is no cycle, so we return false. If we find that slow = fast, this means that the fast pointer has caught up, 
meaning that there has to be a cycle, so return true. 
