1. Distinct Numbers - input values into set and output size of set

2. Apartments - Input vector of wantsizes and apartment sizes. sort both arrays, then use a for loop to iterate through wantsizes array. Use a while loop and var
j to keep track of current apartment element in apartment sizes vector (while wantsize[i] - k > apartments[j]). Then, if apartments[j] is between wantsizes[i] minus 
and plus k, increase answer.

3. Ferris Wheel - vector of kids weights and sort it. See if the first and last element of kids is less than or equal to max weight, and if so, increase j and
decrease n (j is pointer at start of vector, n is pointer at end of vector: they move towards the middle). If not, then only decrease n (combined is greater than
max weight). Increase ans no matter what.

4. Concert Tickets - Insert elements into multiset and use upper_bound for each maximum price. If it == s.begin(), print -1, else print *--it; Then erase the one instance of 
the element from the multiset.

5. Restaurant Customers - Set of arrays of 2 integers. For each customer, insert enter time and 1, and leaving time and -1. Then, iterate through the set and have a value
c in which the 1 and -1 are added to it (2nd element of array) and maximum c is recorded. This is the max number of customers.

6. Movie Festival - Greedy Algorithm. You always want to choose the movie that ends the earliest. Insert into set by {end time, start time} (sort by end time) 
and keep track of the last ending time. If the start time of the next movie is greater or equal to the end of the current movie, increase ans;

7. Sum of Two Values - Put values into a map<int,int> in the form of number, index. For each input, try to find m[sum-k], and if found, print the indexes.

8. Maximum Subarray Sum - Read in first value and assign sum and best to that value. Then, input rest of the values and do sum = max(input, sum+input) to determine
whether to include it in the subarray. Then do best = max(sum, best). This is an important thing to know. 

9. Stick Lengths - You have to use the median for this problem (always optimal). Input the array, sort it, and find the median using the simple formula. Then, iterate back through
the array, incrementing answer by abs(median - element) on each iteration.

10. Missing Coin Sum - Input coins vector and keep track of total value sum. Sort the vector, and keep a variable answer initally 1. Then, iterate through the vector,
access the current element, and if ans < curr, then the sum cannot be created, so output ans. Otherwise, do ans += curr and continue. The reasoning for this can be 
found here: https://www.geeksforgeeks.org/find-smallest-value-represented-sum-subset-given-array/

11. Collecting Numbers 1 - Input first number, if it's not one, increase ans. Keep an array found to keep track of which variables have been found. cin >> the rest of
the array and for each input, do found[input - 1] = 1(-1 bc array indexes). If curr != 1 and found[curr-2] (the number before the current) hasnt been found yet,
increase the answer by one.

12. Collecting Numbers 2 - Same thing as collecting numbers 1 to find the original answer. However, also keep track an array of indexes of each number and 
an array of the numbers at each indexes. Then, for each swap pair, find the numbers at those positions. Use the swap function to swap the positions in 
the nums array. Then, use a series of comparisons based on indexes and number values to change a variable named change. Then, switch the indexes in the indexes 
array. Do ans += change and cout ans;

13. Playlist - Use a map<int, int> and a variable to keep track of the last known duplicate of an element. For each value, if it's already in the map,
then set lastknownduplicate to map[value], and curbest = i (current index) minus lastknownduplicate. Otherwise, just increase curbest by 1. Insert 
i and map[value] and do best = max(best, curbest). Output best at end.

14. Towers - Use a multiset and insert the first value into the multiset. Initiate ans = 1; Then, iterate through the inputs (k). If k >= largest element
of set, you have to make a new tower so ans++ and insert k and continue out of the loop. Otherwise, find the upper bound of k in the set 
(first value greater than k), erase it, and insert k.

15. Traffic Lights - Create a set and input 0 and x into the set. Then, create a multiset of lengths between each stop and insert x. Iterate through the inputs and
for each input k, insert it into the set, find what position it is using .find(), and use variables curleft =  k - *prev(it); and curright = *next(it) - k;
These values are distances that are to the left and right of k (since we split the road up at k). Then we insert those two values into our lengths 
multiset and erase the total distance (curleft + curright) from our multiset, then output the reverse begin of the multiset. 

16. Josephus Problem 1 - Create vector of numbers, then use a while loop while the size is greater than one. Use a for loop to print the current round of numbers
and put the rest of the numbers in another 'survivors' vector. Afterwards, if the initial vector was even, our vector just becomes the survivors vector.
However, if it is of odd size, we have to insert the last element of our survivors vector to the beginning of it, then repeat the loop.

17. Josephus Problem 2 - Use an ordered_set policy-based data structure for efficiency. Insert all of our elements into the ordered set, then define a value p that equals 
k % n. Use the find_by_order function to print out the value at position p in the set, erase that element, and do p = (p+k) % s.size, making sure 
that s.size() is greater than zero.

18. Nested Ranges Check - Complicated Problem. We define a range struct with int left, right, and the original index of the variable (because we sort them).
We also redefine the comparison/sort operator so that if the left values are tied, we sort the right values by whichever one is greater (this is important
for our algorithm). First, we create a vector of ranges and insert our values. Then, we sort the vector. Firstly, to determine if our ranges are contained
by another range, define a variable max for the largest right bound. The way our vector is sorted, if inputs[i].r <= maxi, then that range has to be 
contained by another. Otherwise, we update our max right bound variable. We store these results into our contained array, to be printed later. Next, to 
determine if our ranges contain another range, define a variable min for our minimum right bound and iterate through the vector starting from the back. 
Again, based on the way we sorted our vector, if inputs[i].r >= mini, then it must contain another range. Note: we update the contains and contained array
through our .index range variable, as we have to remember the original index of our input ranges. 

19. Nested Ranges Count - Harder, more complicated problem. Use the same range struct and vector of ranges, but also use an ordered_set of pairs of 
integers. Input and sort the same way as problem 18. For contained, use a for loop and insert inputs[i].r and -1*i into our set. Based on the way 
an ordered set works, we set contained[original index] to the size of the set minus the order_of_key of the inserted values. We do the same thing for 
contains except we start at the back of our vector, and we set contained[original index] only to the order_of_key of the inserted values.

20. Room Allocation - Another pretty complicated problem. Use a vector of pairs of pairs to store enter time, leaving time, and index, then sort the vector.
Make another vector for the assignment of the rooms, each value initialized at -1. Make a variable roomId that represents the current room that has not been 
in use yet, starting at 1. Then, make a priority queue of pairs where the smallest value is on top. Then, iterate through every customer. If the size of the priority queue
is zero (no rooms in use), set roomAssign[index] to roomId, and push the departure time and the roomId onto the priority queue, and increase roomId by one. 
Otherwise, if there is a room or rooms in use, if the .first value of the priority queue (the departure time) is less than the current arrival time, this means
the room is free and we can assign that room to the current customer. Otherwise, there are no free rooms and we have to make another room for the customer.

21. 
