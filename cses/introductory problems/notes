*These solutions, especially the early ones, are pretty rudimentary and inefficient.

1. Weird Algorithm - simple while loop

2. Missing Number - sorted array, iterate through with a for loop. If ans not found, output either first or last element.

3. Repetitions - Iterate through string with array indexes. Keep track of current repetitions and best with max() function.

4. Increasing Array - cin >> the array. Then use a for loop and increment answer by arr[i-1] - arr[i] if the former is larger.

5. Permutations - Input into vector. If n is between 1 and 4, there are specific answers (had to hardcode n = 4 in my code). Otherwise, if n is even, 
switch v[i] and v[i+3] while incrementing i by 2. Ex: 1 2 3 4 5 6 becomes 4 2 6 1 5 3. If n is odd, switch v[i] and v[i+3] AND switch v[i+2] and v[i+4] and
increment i by 2. Ex: 1 2 3 4 5 becomes 4 2 5 1 3.

6. Number spiral - Vector of pairs to represent input points. Algorithm for output is as follows... 
Case 1: row >= col and row is even --> ans = row^2 - col-1;
Case 2: row >= col and row is odd --> ans = (row-1)^2 +1 + col-1;
Case 3: col > row and col is odd  --> ans = col^2 - row-1;
Case 4: col > row and col is even --> ans = (col-1)^2 + 1 + row-1;

7. Two knights - Pure math. total # of places - total ways to attack
total = (k*k)*(k*k - 1)/2; and attack = 4*(k-1)*(k-2); where k is length/width of board.

8. Two sets - Find rem = n%4. If rem == 1 or 2, not possible, but if rem is 3 or 4, it is possible. If 3, input 1 and 2 into set 1 and 3 into set 2. If 4,
input 1 and 4 into set 1 and 2 and 3 into set 2. Then, for the rest of the numbers, input i and i+3 into set 1 and i and i+2 into set 2, incrementing 
i by 4 each time.

9. Bit strings - For each binary digit, there are two possible digits: 1 or 0. So from i = 1 to n inclusive, total = total*2 %MOD, where MOD is needed
bc of overflow. 

10. Trailing Zeroes - There is a certain formula. Start with i = 5 while n/i >= 1, num += n/i. Increment i by a multiple of 5.

11. Coin Piles - Input into vector of pairs. If both piles are zero, YES. If the sum of both piles are less than three, NO. 
If the sum%3 == 0: if pile 1 >= pile 2 and pile 2 * 2 >= pile 1, YES, otherwise NO. Same thing for if pile 2 > pile 1. If sum%3 != 0, NO.

12. Palindrome Reorder - cin >> string input. Iterate through it, and find the count of each letter A-Z in letters array. Then find evencount and oddcount using letters array. 
Keep track of the odd index.
If the size of input is even, if evencount != 26, NO SOLUTION. Otherwise, create a string of half of the letters, then add it to a string of itself reversed.
If the size of input is odd, if evencount != 25 and oddcount != 1, NO SOLUTION. Otherwise, do the same as even but do not include the letters of the 
oddindex, then once half is created, add all oddindex letters then add reverse of first half. 

13. 
